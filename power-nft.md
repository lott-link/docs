# Power NFT

### Simple Summary

It is an NFTcontract that rewards its token owners every round of time by random.

### Abstract

The following NFT contract is an ERC721 standardized smart contract that can live on Ethereum and all other EVM smart chains which Chain link VRF supports.

Power NFT uses Openzeppelin ERC721 implementation as the NFT side and Chainlink VRF as a provably fair and verifiable source to select the winner.

Like other NFTs, Power NFT represents ownership over digital or physical assets. Every power NFT holds a URI that can identify an image, a video, or other files.

Everyone can buy a token using the `buyToken(uri, referral, dappId)` payable function. The contract deposits the paid value in a uint variable as `tokenValue`.

Random number consumer determines next round 'power' and current round's winner token. Selected token charges by withdrawable balance as token value multiplied by the 'power.'.

The owner of the selected token can call the `burnAndWithdraw()` function and withdraw its balance. But the token burns then.

Power NFT uses a peer-to-peer advertisement system. And every person should introduce a referral and dapp which caused they buy a token. Then the contract deposits dapp and referral commission in LottLink Id card. (so they have to own an Id Card)

### Motivation

Power NFT has a living contract and is such an interactive NFT which means it is not just a file or asset. In addition to ERC721 attributes, every NFT has a value and a withdrawable balance that makes it not a simple NFT being.

It is a public contract. Artists can convert their arts to an NFT without deploying an exclusive contract and transfer or sell it directly or in marketplaces.

There is no exclusive dapp. Dapp developers can design their own dapp, use Power NFT, sell NFTs and receive a commission.

In addition to developers, ordinary people can also earn `commission` as `referral`

A decentralized DAO will govern the contract in the final version on the mainnet.

### Functions

#### external functions

<details>

<summary><code>totalValueLocked() public view</code></summary>

Returns the available value that can be transferred to a token withdrawable balance.

</details>

<details>

<summary><code>totalSupply() public view</code></summary>

Returns total tokens minted.

</details>

<details>

<summary><code>lastRandom() public view</code></summary>

Returns the last randomness generated by the [RNC](rnc.md) contract.

</details>

<details>

<summary><code>tokenValue(uint256 tokenId) public view</code></summary>

Returns the value which the minter deposited in the token.

Requirements:

* `tokenId` must exist.

</details>

<details>

<summary><code>tokenValue(uint256 tokenId) public view</code></summary>

Returns the value which the minter deposited in the token.

Requirements:

* `tokenId` must exist.

</details>

<details>

<summary><code>tokenBalance(uint256 tokenId) public view</code></summary>

Returns the value which the minter deposited in the token.

Requirements:

* `tokenId` must exist.

</details>

<details>

<summary><code>buyToken(string memory uri, string memory referral, uint256 dappId) external payable</code></summary>

Mints a token by desired uri and value and transfer it to `msg.sender`.

The first `tokenId` is 1 and the next one will be earned by auto-increment. if a token is burned, the contract assigns its Id to the next one who buys a token.

Commission will be deducted from `msg.value` and transferred to the commission contract to be shared between referral, dapp, and DAO. the rest of the value will be locked in the contract.

Requirements:

* `referral` and `dappId` must exist.

</details>

<details>

<summary><code>rollDice() external</code></summary>

Requests to the [RNC](rnc.md) to consume randomness.

Requirements:

* there must be one or more round times available between the current time and `roundTimesPassed`.
* required `RNCFee()` should be available in the `totalValueLocked()`.

Emits a `RollDice` event.

</details>

<details>

<summary><code>select(uint256 _randomness) external</code></summary>

Fulfills randomness, selects a card, and determines the power of the next round by random.

Random token Id will be selected from an unfixed pool that depends on `additionalSupplyPercent`. if it is zero, we have a winner every round. else, winning possibility is inversely proportional to `totalSupply` + `additionalSupplyPercent`.

The selected token value will equal `tokenValue` \* `power`.

If someone doesn't withdraw and burn their token and the token is selected by random again, its recent balance will be recycled to the contract.

&#x20;Requirements:

* only RNC can call this function

Emits a `Win` event.

</details>

<details>

<summary></summary>



</details>

<details>

<summary></summary>



</details>

<details>

<summary></summary>



</details>

